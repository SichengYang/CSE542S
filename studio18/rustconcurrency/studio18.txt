1. Sicheng Yang sicheng@wustl.edu
Qinzhou Song qinzhounick@wustl.edu

2.
[qinzhounick@iht32-1502 rustconcurrency]$ cargo run
   Compiling rustconcurrency v0.1.0 (/home/warehouse/qinzhounick/cse542/studio18/rustconcurrency)
    Finished dev [unoptimized + debuginfo] target(s) in 1.70s
     Running `target/debug/rustconcurrency`
Hello, world!

3.
[qinzhounick@iht32-1502 rustconcurrency]$ cargo run
   Compiling rustconcurrency v0.1.0 (/home/warehouse/qinzhounick/cse542/studio18/rustconcurrency)
    Finished dev [unoptimized + debuginfo] target(s) in 1.36s
     Running `target/debug/rustconcurrency`
Child spawned!
Hello, world!

4.
code:
fn main() {
    let mut v = vec![];
    for arg in env::args(){
        let child = thread::spawn(move || {println!("arg: {arg}")});
        v.push(child);
    }
    
    for child in v{
        child.join().unwrap();
    }
    
    println!("Hello, world!");
}

Output:
[qinzhounick@iht32-1502 rustconcurrency]$ cargo run 1 2 3 4 5
   Compiling rustconcurrency v0.1.0 (/home/warehouse/qinzhounick/cse542/studio18/rustconcurrency)
    Finished dev [unoptimized + debuginfo] target(s) in 1.59s
     Running `target/debug/rustconcurrency 1 2 3 4 5`
arg: target/debug/rustconcurrency
arg: 1
arg: 4
arg: 3
arg: 2
arg: 5
Hello, world!

5.
Code:
fn print_file(filename: &String){
    let file = File::open(filename);
    match file{
        Err(e) => println!("File name: {filename} Error: {e}"),
        Ok(file) => {
            let f = BufReader::new(file);
            for line in f.lines(){
                match line{
                    Ok(s) => if !s.is_empty() {println!("{s}")},
                    _ => return
                }
            }
        }
    }
}
fn main() {
    let mut v = vec![];
    for arg in env::args(){
        let child = thread::spawn(move || {print_file(&arg.to_string())});
        v.push(child);
    }
    
    for child in v{
        child.join().unwrap();
    }
    
    println!("Hello, world!");
}

Output:
[qinzhounick@iht32-1502 rustconcurrency]$ cargo run Cargo.lock ../Cargo.lock Cargo.toml ../Cargo.toml
   Compiling rustconcurrency v0.1.0 (/home/warehouse/qinzhounick/cse542/studio18/rustconcurrency)
    Finished dev [unoptimized + debuginfo] target(s) in 2.28s
     Running `target/debug/rustconcurrency Cargo.lock ../Cargo.lock Cargo.toml ../Cargo.toml`
File name: ../Cargo.lock Error: No such file or directory (os error 2)
File name: ../Cargo.toml Error: No such file or directory (os error 2)
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 3
[[package]]
name = "rustconcurrency"
version = "0.1.0"
[package]
name = "rustconcurrency"
version = "0.1.0"
edition = "2021"
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[dependencies]
Hello, world!

6.
Code:
fn main() -> std::io::Result<()>{
    let listener = TcpListener::bind("127.0.0.1:80")?;
    let child = thread::spawn(move || {
        match listener.accept(){
            Err(e) => println!("Connection error: {e}"),
            Ok((mut stream, addr)) => {
                println!("address: {addr}");
                let mut buffer = [0;512];

                while(1){
                    match stream.read(&mut buffer){
                        Ok(byte_read) => {
                            if let Ok(message) = String::from_utf8(buffer[..byte_read].to_vec()){
                                println!("Received messages:\n{message}");
                            }
                        },
                        Err(e) => println!("Err: {e}"),
                    }
                }
                 
            }
        }    
    });

    let mut stream = TcpStream::connect("127.0.0.1:80").expect("Couldn't connect to the server...");
    for arg in env::args(){
        match stream.write(arg.as_bytes()){
            Err(e) => println!("Err sending args: {e}"),
            Ok(_) => {}
        }
    }
    stream.shutdown(Shutdown::Both).expect("shutdown call failed");
    child.join().unwrap();

    Ok(())
}


Output:
Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.53s
     Running `target\debug\rustconcurrency.exe 1 2 3 4 5`
address: 127.0.0.1:50172
Received messages:
target\debug\rustconcurrency.exe12345

7.
C:\Users\NickS\Documents\GitHub\CSE542S\studio18\rustconcurrency>cargo run 1 2 3 4 5
   Compiling rustconcurrency v0.1.0 (C:\Users\NickS\Documents\GitHub\CSE542S\studio18\rustconcurrency)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 0.25s
     Running `target\debug\rustconcurrency.exe 1 2 3 4 5`
address: 127.0.0.1:50383
Received messages:
target\debug\rustconcurrency.exe1234
Received messages:
5
Received messages:

error: process didn't exit successfully: `target\debug\rustconcurrency.exe 1 2 3 4 5` (exit code: 0xc000013a, STATUS_CONTROL_C_EXIT)

Because the child thread is still listening and trying to accept other connections, so the main program would not terminate.

8.
Our program worked as expected without the extra call to connect after setting the flag. If the connect call is moved after the child joins,
  the connect call would fail because there is no listeners anymore.
